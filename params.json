{"name":"Blogcat","tagline":"Blogcat","body":"# XB系列第二弹 - 航海记录 BlogCat #\r\n这是一份关于个人「项目」xbp2.apk开发过程的记录\r\n<br>\r\n### 综述\r\n- 项目名:`xbp2` = XB Project two(base Android)\r\n- `xbp2`的目标是做一个使用[`ViewPager`](http://developer.android.com/reference/android/support/v4/view/ViewPager.html \"ViewPager\")开发的多屏应用并集合多种功能\r\n- 目前的计划是拥有三屏\t\r\n<br><br>\t\r\n### 实现功能 \r\n- Tab one:可定制个人课程(表)。鉴于已有的很多App都是通过社交账号授权，然后通过社交关系匹配导入数据，很自动化。`xbp2`做的是手动(别手懒~)，这东西没必要被人又挖了一次数据,try to offline:)\r\n- Tab two:模仿**Catch Note**的TODO List\r\n- Tab three:加入之前做到半成品的XB([传送门](https://github.com/hanaarena/XB))\r\n<br><br>\r\n### 进展  (Oct.31)\r\n- Tab one 基本完成\r\n- Tab two 时间提醒功能√ 日期提醒功能√(device关机后失效，目测是没有写进数据库之类的) 自定义提醒内容至Notification√   ···\r\n- 使用`WebView`包装√\r\n<br>\r\n----------\r\n<br>\r\n### blogcat\r\n##### Tab one\r\n Android 官方[`ViewPager`](http://developer.android.com/reference/android/support/v4/view/ViewPager.html \"ViewPager\")文档的example推荐用 `TabsAdapter` 来做`ViewPager`的容器，但是在用`new TabsAdapter`的 `.addTab()` 方法时我不知道怎麽用`TabListener`来监听滑到当前Tab的方法,只能做一些视图的查看。\r\n    <pre>\r\n protected void onCreate(Bundle savedInstanceState) { \r\n    mViewPager = new ViewPager(this);\r\n    ....\r\n    setContentView(mViewPager);\r\n    ....\r\n    mTabsAdapter = new TabsAdapter(this, mViewPager);\r\n }\r\n </pre>\r\n>效果如图：![](https://raw.github.com/hanaarena/blogcat/gh-pages/images/2013-10-19_121158.png)\r\n\r\n所以我选择了另一种方法List<view>来做每一屏(Tab)的容器:\r\n<pre>\r\nprotected void onCreate(Bundle savedInstanceState) {\r\n\tsuper.onCreate(savedInstanceState);\r\n\trequestWindowFeature(Window.FEATURE_NO_TITLE);\r\n\tsetContentView(R.layout.activity_main);\t\r\n\t\r\n\tviewPager = (ViewPager) this.findViewById(R.id.viewpager);\r\n\tpagerTitleStrip = (PagerTitleStrip) this.findViewById(R.id.pagertitile);\r\n\tpagerTitleStrip.setTextColor(Color.WHITE);\r\n\r\n\tView view1 = LayoutInflater.from(MainActivity.this).inflate(\r\n\t\t\t\tR.layout.tab1, null);\r\n\t....\r\n\r\n\tlist = new ArrayList<View>();\r\n\tlist.add(view1);\r\n\t...\r\n}\r\n</pre>\r\n>效果如图：![](https://raw.github.com/hanaarena/blogcat/gh-pages/images/2013-10-19_121507.png)\r\n\r\n在后者的方法能直接实现对每一屏(Tab)中各控件的事件监听，而无需去实现`TabsListener`之类的监听接口.\r\n\r\n##### Tab two\r\n第二屏中通过点击Button控件调用`Time/DatePickerDialog`来进行时间/日期的选择。([More about `Picker`](http://developer.android.com/guide/topics/ui/controls/pickers.html))\r\n\r\nTab2.xml:\r\n\r\n    <Button\r\n\t\tandroid:id=\"@+id/button1\"\r\n\t\tandroid:layout_width=\"wrap_content\"\r\n\t\tandroid:layout_height=\"wrap_content\"\r\n\t\t······\r\n\t\tandroid:text=\"@string/btn_date\" \r\n\t\tandroid:onClick=\"showdateTime\" />\r\n\r\n在实现类文件中实现`onClick`事件的方法(这里指`showdateTime`):\r\n\r\n\tpublic void showdateTime(View v)\r\n\t{\r\n\t\t// 创建一个TimePickerDialog实例，并把它显示出来。\r\n\t\tnew TimePickerDialog(MainActivity.this,\r\n\t\t\t0, // 绑定监听器\r\n\t\t\tnew TimePickerDialog.OnTimeSetListener()\r\n\t\t\t{\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onTimeSet(TimePicker tp, int hourOfDay,\r\n\t\t\t\t\tint minute)\r\n\t\t\t\t{\r\n\t\t\t\t\t myCalendar.setTimeInMillis(System.currentTimeMillis());        //设置Calendar对象\r\n\t\t\t\t\t myCalendar.set(Calendar.HOUR_OF_DAY, hourOfDay);        //设置闹钟小时数\r\n\t\t\t\t\t myCalendar.set(Calendar.MINUTE, minute);            //设置闹钟的分钟数\r\n\t\t\t\t\t myCalendar.set(Calendar.SECOND, 0);                //设置闹钟的秒数\r\n\t\t\t\t\t myCalendar.set(Calendar.MILLISECOND, 0);            //设置闹钟的毫秒数\r\n                     Intent intent = new Intent(MainActivity.this, AlarmReceiver.class);    //创建Intent对象\r\n                     PendingIntent pi = PendingIntent.getBroadcast(MainActivity.this, 0, intent, 0);    //创建PendingIntent          \r\n             \t\t // 获取AlarmManager对象\r\n             \t\t aManager = (AlarmManager) getSystemService(ALARM_SERVICE);\t\t\r\n                     aManager.set(AlarmManager.RTC_WAKEUP, myCalendar.getTimeInMillis(), pi);        //设置闹钟\r\n                     //aManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi);        //设置当前时间闹钟\r\n                     Toast.makeText(MainActivity.this, \"闹钟设置成功\", Toast.LENGTH_SHORT).show();//提示用户\r\n\t\t\t\t}\r\n\t\t\t}, myCalendar.get(Calendar.HOUR_OF_DAY)\r\n\t\t\t, myCalendar.get(Calendar.MINUTE), true)\r\n\t\t\t.show();\t\t\t\t\r\n\t}\r\n**Waring：**\r\n\r\n\tmyCalendar.set(Calendar.HOUR_OF_DAY, hourOfDay); \r\n与\r\n\r\n\tmyCalendar.set(Calendar.HOUR, hourOfDay); \r\n的区别，如果用HOUR的话只能识别12小时制(虽然能选择12点过后的钟点,但是并不能实现定时闹钟功能)。应使用HOUR_OF _DAY\r\n\r\n（P.s. 调用日期Picker同理~）\r\n\r\n----------\r\n\r\n\r\n<del>下一步要先实现的是自定义`Toast`内容，即将`EditText`中的内容传输到`Toast`控件中，并用`SharedPreferenced`保存。<br /></del>\r\n**调用`Noitification.Builder`**([More about `Notification.Builder`](http://developer.android.com/reference/android/app/Notification.Builder.html))\r\n\r\n顶部显示notification，下拉查看自定义的提醒内容。这里使用`JSP`的`Session`来代替`Intent.putExtra()`.   //改天用putExtra改写\r\n\r\nSession.java:\r\n<pre>\r\npublic class Session {\r\n\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprivate Map _objectContainer;\r\n\r\n\tprivate static Session session;\r\n\r\n\t// Attention here, DO NOT USE keyword 'new' to create this object.\r\n\t// Instead, use getSession method.\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprivate Session() {\r\n\t\t_objectContainer = new HashMap();\r\n\t}\r\n\r\n\tpublic static Session getSession() {\r\n\r\n\t\tif (session == null) {\r\n\t\t\tsession = new Session();\r\n\t\t\treturn session;\r\n\t\t} else {\r\n\t\t\treturn session;\r\n\t\t}\r\n\t}\r\n\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic void put(Object key, Object value) {\r\n\r\n\t\t_objectContainer.put(key, value);\r\n\t}\r\n\r\n\tpublic Object get(Object key) {\r\n\r\n\t\treturn _objectContainer.get(key);\r\n\t}\r\n\r\n\tpublic void cleanUpSession() {\r\n\t\t_objectContainer.clear();\r\n\t}\r\n\r\n\tpublic void remove(Object key) {\r\n\t\t_objectContainer.remove(key);\r\n\t}\r\n}\r\n</pre>\r\n\r\n----------\r\n\r\n使用Notification.Builder实现通知栏功能：\r\n\r\n\t\tIntent notificationIntent = new Intent(context, SecondActivity.class);\r\n\t\tPendingIntent contentIntent = PendingIntent.getActivity(context, 0, notificationIntent, 0);\r\n\t\tNotificationManager nm = (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);\r\n\r\n\t\tNotification.Builder builder = new Notification.Builder(context);\r\n\t\tbuilder.setContentIntent(contentIntent)\r\n\t\t            .setSmallIcon(R.drawable.heart)\r\n\t\t            .setTicker(\"Helo Noti\")\r\n\t\t            .setWhen(System.currentTimeMillis())\r\n\t\t            .setAutoCancel(true)\r\n\t\t            .setContentTitle(\"Helo Noti2\")\r\n\t\t            .setContentText(notiText);\r\n\t\tNotification n = builder.build();\t\t\r\n\t\tnm.notify(1, n)\r\n\r\n(以下包含在AlarmReceive.java中，AlarmReciver继承`BroadcastReceiver`。在MainActivity.java中，设定闹钟到点时 `PendingIntent pi = PendingIntent.getBroadcast(MainActivity.this, 0, intent, 0);)`,而不是使用`.getActivity()` )\r\n\r\n**Tips：**\r\n\r\n①\r\n\r\n存储数据：\r\n\r\n\ttext = (EditText)view2.findViewById(R.id.text); //注意：view2！\r\n\tSession session = Session.getSession();\r\n\tString str2 = text.getText().toString();\t//获取EditText中输入的内容\r\n\tsession.put(\"str\", str2);\r\n\r\n读取数据：\r\n\r\n\tSession session = Session.getSession();\r\n    session.get(\"str\");\r\n\r\n②\r\n\r\nEclipse报错 **error opening trace file: No such file or directory (2)**,一般是AndroidManifest.xml中有出错.\r\n\r\n\r\n----------\r\n使用Dialog重写显示时间、日期选择的方法：\r\n\r\n即用`DatePickerDialog` & `TimePickerDialog`来显示日期/时间{弹出框}\r\n\r\n\t//Date Picker\r\n\tclass showDatePicker implements OnClickListener {\r\n\r\n\t\t@Override\r\n\t\tpublic void onClick(View v) {\r\n\t\t\tfinal Calendar c = Calendar.getInstance();\r\n\t\t\tcurrentDate = Calendar.getInstance();\r\n\t\t\tint mYear = c.get(Calendar.YEAR);\r\n\t\t\tint mMonth = c.get(Calendar.MONTH);\r\n\t\t\tint mDay = c.get(Calendar.DAY_OF_MONTH);\r\n\t\t\t\r\n\t\t\tDialog dialog = new DatePickerDialog(MainActivity.this,\r\n\t\t\t\t\tnew DatePickerDialog.OnDateSetListener() {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic void onDateSet(DatePicker view, int year, int monthOfYear,\r\n\t\t\t\t\t\t\t\tint dayOfMonth) {\r\n\t\t\t\t\t\t\tString date = \"\";\r\n\t\t\t\t\t\t\tdate += year;\r\n\t\t\t\t\t\t\tif(monthOfYear < 9) {\r\n\t\t\t\t\t\t\t\tdate += \"-0\" + (monthOfYear+1);\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tdate += \"-\" + (monthOfYear+1);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(dayOfMonth < 10) {\r\n\t\t\t\t\t\t\t\tdate += \"-0\" + dayOfMonth;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tdate += \"-\" + dayOfMonth;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tdateView.setText(date);\t\t\t\t\t\r\n\t\t\t\t\t\t\tc.getTimeInMillis();\r\n\t\t\t\t\t\t\tc.set(Calendar.YEAR, year);\r\n\t\t\t\t\t\t\tc.set(Calendar.MONTH, monthOfYear);\r\n\t\t\t\t\t\t\tc.set(Calendar.DAY_OF_MONTH, dayOfMonth);\r\n\t\t\t\t\t\t\t//Selected Date was less than system Date\r\n\t\t\t\t\t\t\tif(currentDate.getTimeInMillis() > c.getTimeInMillis()) {\r\n\t\t\t\t\t\t\t\tToast.makeText(MainActivity.this, \"不能小于当前日期！\",Toast.LENGTH_SHORT).show();\r\n\t\t\t\t\t\t\t\tfinal Calendar currentTime = Calendar.getInstance();\r\n\t\t\t\t\t\t\t\tfinal int mYear2 = currentTime.get(Calendar.YEAR);\r\n\t\t\t\t\t\t\t\tfinal int mMonth2 = currentTime.get(Calendar.MONTH);\r\n\t\t\t\t\t\t\t\tfinal int mDay2 = currentTime.get(Calendar.DAY_OF_MONTH);\r\n\t\t\t\t\t\t\t\tString tempDate2 = mYear2 + \"-\" + format(mMonth2+1) + \"-\" + format(mDay2);\r\n\t\t\t\t\t\t\t\tdateView.setText(tempDate2);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tmyCalendar.set(Calendar.YEAR, year);\r\n\t\t\t\t\t\t\tmyCalendar.set(Calendar.MONTH, monthOfYear);\r\n\t\t\t\t\t\t\tmyCalendar.set(Calendar.DAY_OF_MONTH, dayOfMonth);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, mYear, mMonth, mDay);\r\n\t\t\tdialog.show();\r\n\t\t}\t\t\r\n\t}\r\n\t\r\n\t//Time Picker\r\n\tclass showTimePicker implements OnClickListener {\r\n\r\n\t\t@Override\r\n\t\tpublic void onClick(View v) {\r\n\t\t\tfinal Calendar c = Calendar.getInstance();\r\n\t\t\tcurrentTime = Calendar.getInstance();\r\n\t\t\tfinal int mHour = c.get(Calendar.HOUR_OF_DAY);\r\n\t\t\tfinal int mMinute = c.get(Calendar.MINUTE);\r\n\t\t\t\r\n\t\t\tDialog dialog = new TimePickerDialog(MainActivity.this,\r\n\t\t\t\t\tnew TimePickerDialog.OnTimeSetListener() {\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\tpublic void onTimeSet(TimePicker view, int hourOfDay, int minute) {\r\n\t\t\t\t\t\t\tString time = \"\";\r\n\t\t\t\t\t\t\tif(hourOfDay < 10) {\r\n\t\t\t\t\t\t\t\ttime = \"0\" + hourOfDay;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\ttime = hourOfDay + \"\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(minute < 10) {\r\n\t\t\t\t\t\t\t\ttime += \" : 0\" + minute;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\ttime += \" : \" + minute;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ttimeView.setText(time);\r\n\t\t\t\t\t\t\t//Selected Time\r\n\t\t\t\t\t\t\tmyCalendar.set(Calendar.HOUR_OF_DAY, hourOfDay);\r\n\t\t\t\t\t\t\tmyCalendar.set(Calendar.MINUTE, minute);\r\n\t\t\t\t\t\t\tmyCalendar.set(Calendar.SECOND, 0);\r\n\t\t\t\t\t\t\tmyCalendar.set(Calendar.MILLISECOND, 0);\r\n\t\t\t\t\t\t\t//IF Selected Time was less than the syetem Time\r\n\t\t\t\t\t\t\tif(myCalendar.getTimeInMillis() < currentTime.getTimeInMillis()) {\r\n\t\t\t\t\t\t\t\tmyCalendar.set(Calendar.DAY_OF_YEAR, myCalendar.get(Calendar.DAY_OF_YEAR)+1);\r\n\t\t\t\t\t\t\t\tCalendar calendar = Calendar.getInstance();\r\n\t\t\t\t\t\t\t\tcalendar.add(Calendar.DATE, 1);\r\n\t\t\t\t\t\t\t\tint y = calendar.get(Calendar.YEAR);\r\n\t\t\t\t\t\t\t\tint m = calendar.get(Calendar.MONTH);\r\n\t\t\t\t\t\t\t\tint d = calendar.get(Calendar.DAY_OF_MONTH);\r\n\t\t\t\t\t\t\t\tString date2 = \"\";\r\n\t\t\t\t\t\t\t\tdate2 += date2 +y;\r\n\t\t\t\t\t\t\t\tif(m <9) {\r\n\t\t\t\t\t\t\t\t\tdate2 += \"-0\" + (m+1);\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tdate2 += \"-\" +(m+1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(d < 10) {\r\n\t\t\t\t\t\t\t\t\tdate2 += \"-0\" + d;\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tdate2 += \"-\" + d;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tdateView.setText(date2);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}, mHour, mMinute, true);\r\n\t\t\tdialog.show();\r\n\t\t}\t\r\n\t\r\n\r\n----------\r\n##### Tab three \r\n\r\n\t\t//WebView\r\n\t\tmyWebView = (WebView)view3.findViewById(R.id.webview);\r\n\t\tmyWebView.loadUrl(\"http://lanzc.com/wb\"); //跳转到微博页面\r\n\t\tmyWebView.setWebViewClient(new WebViewClient()); //在WebView中点击链接不另外跳转，在WebView page中打开\r\n\t\tWebSettings webSettings = myWebView.getSettings();\r\n\t\twebSettings.setJavaScriptEnabled(true);\r\n\r\n##### 关于WebView中back button事件\r\n\r\n否则···按返回键将直接跳出Activity···\r\n\r\n\t@Override\r\n\tpublic boolean onKeyDown(int keyCode, KeyEvent event) {\r\n\t    // Check if the key event was the Back button and if there's history\r\n\t    if ((keyCode == KeyEvent.KEYCODE_BACK) && myWebView.canGoBack()) {\r\n\t        myWebView.goBack();\r\n\t        return true;\r\n\t    }\r\n\t    // If it wasn't the Back key or there's no web page history, bubble up to the default\r\n\t    // system behavior (probably exit the activity)\r\n\t    return super.onKeyDown(keyCode, event);\r\n\t}\r\n\r\n----------\r\n## END ##\r\n基本的功能都实现得差不多，然后，xbp2先做到这里吧。 \r\n\r\n*To be continued···*\r\n\r\n以上。\r\n\r\nOct.31 2013@lanz","google":"UA-30427812","note":"Don't delete this file! It's used internally to help with page regeneration."}