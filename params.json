{"name":"Blogcat","tagline":"Blogcat","body":"# XB系列第二弹 - 航海记录 BlogCat #\r\n这是一份关于个人「项目」xbp2.apk开发过程的记录\r\n<br>\r\n### 综述\r\n- 项目名:`xbp2` = XB Project two(base Android)\r\n- `xbp2`的目标是做一个使用[`ViewPager`](http://developer.android.com/reference/android/support/v4/view/ViewPager.html \"ViewPager\")开发的多屏应用并集合多种功能\r\n- 目前的计划是拥有三屏\t\r\n\r\n### 实现功能 \r\n\r\n- Tab one:可定制个人课程(表)。鉴于已有的很多App都是通过社交账号授权，然后通过社交关系匹配导入数据，很自动化。`xbp2`做的是手动(别手懒~)，这东西没必要被人又挖了一次数据,try to offline:)\r\n- Tab two:模仿**Catch Note**的TODO List\r\n- Tab three:加入之前做到半成品的XB([传送门](https://github.com/hanaarena/XB))\r\n<br><br>\r\n\r\n### 进展  (Oct.19)\r\n\r\n- Tab one 基本完成\r\n- Tab two 提醒功能√ ···\r\n- 使用`WebView`包装\r\n<br>\r\n\r\n***\r\n\r\n\r\n### blogcat\r\n\r\n#### Tab one\r\n\r\n Android 官方[`ViewPager`](http://developer.android.com/reference/android/support/v4/view/ViewPager.html \"ViewPager\")文档的example推荐用 `TabsAdapter` 来做`ViewPager`的容器，但是在用`new TabsAdapter`的 `.addTab()` 方法时我不知道怎麽用`TabListener`来监听滑到当前Tab的方法,只能做一些视图的查看。\r\n    <pre>\r\n protected void onCreate(Bundle savedInstanceState) { \r\n    mViewPager = new ViewPager(this);\r\n    ....\r\n    setContentView(mViewPager);\r\n    ....\r\n    mTabsAdapter = new TabsAdapter(this, mViewPager);\r\n }\r\n </pre>\r\n\r\n效果如图：![](https://raw.github.com/hanaarena/blogcat/gh-pages/images/2013-10-19_121158.png)\r\n\r\n所以我选择了另一种方法List<view>来做每一屏(Tab)的容器:\r\n<pre>\r\nprotected void onCreate(Bundle savedInstanceState) {\r\n\tsuper.onCreate(savedInstanceState);\r\n\trequestWindowFeature(Window.FEATURE_NO_TITLE);\r\n\tsetContentView(R.layout.activity_main);\t\r\n\t\r\n\tviewPager = (ViewPager) this.findViewById(R.id.viewpager);\r\n\tpagerTitleStrip = (PagerTitleStrip) this.findViewById(R.id.pagertitile);\r\n\tpagerTitleStrip.setTextColor(Color.WHITE);\r\n\r\n\tView view1 = LayoutInflater.from(MainActivity.this).inflate(\r\n\t\t\t\tR.layout.tab1, null);\r\n\t....\r\n\r\n\tlist = new ArrayList<View>();\r\n\tlist.add(view1);\r\n\t...\r\n}\r\n</pre>\r\n\r\n效果如图：<br />\r\n![](https://raw.github.com/hanaarena/blogcat/gh-pages/images/2013-10-19_121507.png)\r\n\r\n在后者的方法能直接实现对每一屏(Tab)中各控件的事件监听，而无需去实现`TabsListener`之类的监听接口.\r\n\r\n#### Tab two\r\n第二屏中通过点击Button控件调用`Time/DatePickerDialog`来进行时间/日期的选择。([More about `Picker`](http://developer.android.com/guide/topics/ui/controls/pickers.html))\r\n\r\nTab2.xml:\r\n\r\n    <Button\r\n\t\tandroid:id=\"@+id/button1\"\r\n\t\tandroid:layout_width=\"wrap_content\"\r\n\t\tandroid:layout_height=\"wrap_content\"\r\n\t\t······\r\n\t\tandroid:text=\"@string/btn_date\" \r\n\t\tandroid:onClick=\"showdateTime\" />\r\n\r\n在实现类文件中实现`onClick`事件的方法(这里指`showdateTime`):\r\n\r\n\tpublic void showdateTime(View v)\r\n\t{\r\n\t\t// 创建一个TimePickerDialog实例，并把它显示出来。\r\n\t\tnew TimePickerDialog(MainActivity.this,\r\n\t\t\t0, // 绑定监听器\r\n\t\t\tnew TimePickerDialog.OnTimeSetListener()\r\n\t\t\t{\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onTimeSet(TimePicker tp, int hourOfDay,\r\n\t\t\t\t\tint minute)\r\n\t\t\t\t{\r\n\t\t\t\t\t myCalendar.setTimeInMillis(System.currentTimeMillis());        //设置Calendar对象\r\n\t\t\t\t\t myCalendar.set(Calendar.HOUR_OF_DAY, hourOfDay);        //设置闹钟小时数\r\n\t\t\t\t\t myCalendar.set(Calendar.MINUTE, minute);            //设置闹钟的分钟数\r\n\t\t\t\t\t myCalendar.set(Calendar.SECOND, 0);                //设置闹钟的秒数\r\n\t\t\t\t\t myCalendar.set(Calendar.MILLISECOND, 0);            //设置闹钟的毫秒数\r\n                     Intent intent = new Intent(MainActivity.this, AlarmReceiver.class);    //创建Intent对象\r\n                     PendingIntent pi = PendingIntent.getBroadcast(MainActivity.this, 0, intent, 0);    //创建PendingIntent          \r\n             \t\t // 获取AlarmManager对象\r\n             \t\t aManager = (AlarmManager) getSystemService(ALARM_SERVICE);\t\t\r\n                     aManager.set(AlarmManager.RTC_WAKEUP, myCalendar.getTimeInMillis(), pi);        //设置闹钟\r\n                     //aManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi);        //设置当前时间闹钟\r\n                     Toast.makeText(MainActivity.this, \"闹钟设置成功\", Toast.LENGTH_SHORT).show();//提示用户\r\n\t\t\t\t}\r\n\t\t\t}, myCalendar.get(Calendar.HOUR_OF_DAY)\r\n\t\t\t, myCalendar.get(Calendar.MINUTE), true)\r\n\t\t\t.show();\t\t\t\t\r\n\t}\r\n**Waring：**\r\n\r\n\tmyCalendar.set(Calendar.HOUR_OF_DAY, hourOfDay); \r\n与\r\n\r\n\tmyCalendar.set(Calendar.HOUR, hourOfDay); \r\n的区别，如果用HOUR的话只能识别12小时制(虽然能选择12点过后的钟点,但是并不能实现定时闹钟功能)。应使用HOUR_OF _DAY\r\n\r\n（P.s. 调用日期Picker同理~）\r\n\r\n<del>下一步要先实现的是自定义`Toast`内容，即将`EditText`中的内容传输到`Toast`控件中，并用`SharedPreferenced`保存。<br /></del>\r\n**调用`Noitification.Builder`**([More about `Notification.Builder`](http://developer.android.com/reference/android/app/Notification.Builder.html))\r\n\r\n顶部显示notification，下拉查看自定义的提醒内容。这里使用`JSP`的`Session`来代替`Intent.putExtra()`.   //改天用putExtra改写\r\n\r\nSession.java:\r\n<pre>\r\npublic class Session {\r\n\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprivate Map _objectContainer;\r\n\r\n\tprivate static Session session;\r\n\r\n\t// Attention here, DO NOT USE keyword 'new' to create this object.\r\n\t// Instead, use getSession method.\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tprivate Session() {\r\n\t\t_objectContainer = new HashMap();\r\n\t}\r\n\r\n\tpublic static Session getSession() {\r\n\r\n\t\tif (session == null) {\r\n\t\t\tsession = new Session();\r\n\t\t\treturn session;\r\n\t\t} else {\r\n\t\t\treturn session;\r\n\t\t}\r\n\t}\r\n\r\n\t@SuppressWarnings(\"unchecked\")\r\n\tpublic void put(Object key, Object value) {\r\n\r\n\t\t_objectContainer.put(key, value);\r\n\t}\r\n\r\n\tpublic Object get(Object key) {\r\n\r\n\t\treturn _objectContainer.get(key);\r\n\t}\r\n\r\n\tpublic void cleanUpSession() {\r\n\t\t_objectContainer.clear();\r\n\t}\r\n\r\n\tpublic void remove(Object key) {\r\n\t\t_objectContainer.remove(key);\r\n\t}\r\n}\r\n</pre>\r\n\r\n使用Notification.Builder实现通知栏功能：\r\n\r\n\t\tIntent notificationIntent = new Intent(context, SecondActivity.class);\r\n\t\tPendingIntent contentIntent = PendingIntent.getActivity(context, 0, notificationIntent, 0);\r\n\t\tNotificationManager nm = (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);\r\n\r\n\t\tNotification.Builder builder = new Notification.Builder(context);\r\n\t\tbuilder.setContentIntent(contentIntent)\r\n\t\t            .setSmallIcon(R.drawable.heart)\r\n\t\t            .setTicker(\"Helo Noti\")\r\n\t\t            .setWhen(System.currentTimeMillis())\r\n\t\t            .setAutoCancel(true)\r\n\t\t            .setContentTitle(\"Helo Noti2\")\r\n\t\t            .setContentText(notiText);\r\n\t\tNotification n = builder.build();\t\t\r\n\t\tnm.notify(1, n)\r\n\r\n(以下包含在AlarmReceive.java中，AlarmReciver继承`BroadcastReceiver`。在MainActivity.java中，设定闹钟到点时 `PendingIntent pi = PendingIntent.getBroadcast(MainActivity.this, 0, intent, 0);)`,而不是使用`.getActivity()` )\r\n\r\n**Tips：**\r\n\r\n①\r\n\r\n存储数据：\r\n\r\n\ttext = (EditText)view2.findViewById(R.id.text);\r\n\tSession session = Session.getSession();\r\n\tString str2 = text.getText().toString();\t//获取EditText中输入的内容\r\n\tsession.put(\"str\", str2);\r\n\r\n读取数据：\r\n\r\n\tSession session = Session.getSession();\r\n    session.get(\"str\");\r\n\r\n②\r\n\r\nEclipse报错 **error opening trace file: No such file or directory (2)**,一般是AndroidManifest.xml中有出错.","google":"UA-30427812","note":"Don't delete this file! It's used internally to help with page regeneration."}