{"name":"Blogcat","tagline":"Blogcat","body":"# XB系列第二弹 - 航海记录 BlogCat #\r\n这是一份关于个人「项目」xbp2.apk开发过程的记录\r\n<br>\r\n### 综述\r\n- 项目名:`xbp2` = XB Project two(base Android)\r\n- `xbp2`的目标是做一个使用[`ViewPager`](http://developer.android.com/reference/android/support/v4/view/ViewPager.html \"ViewPager\")开发的多屏应用并集合多种功能\r\n- 目前的计划是拥有三屏\t\r\n\r\n### 实现功能 \r\n\r\n- Tab one:可定制个人课程(表)。鉴于已有的很多App都是通过社交账号授权，然后通过社交关系匹配导入数据，很自动化。`xbp2`做的是手动(别手懒~)，这东西没必要被人又挖了一次数据,try to offline:)\r\n- Tab two:模仿**Catch Note**的TODO List\r\n- Tab three:加入之前做到半成品的XB([传送门](https://github.com/hanaarena/XB))\r\n<br><br>\r\n\r\n### 进展  (Oct.19)\r\n\r\n- Tab one 基本完成\r\n- Tab two 提醒功能√ ···\r\n- 使用`WebView`包装\r\n<br>\r\n\r\n***\r\n\r\n\r\n### blogcat\r\n\r\n#### Tab one\r\n\r\n Android 官方[`ViewPager`](http://developer.android.com/reference/android/support/v4/view/ViewPager.html \"ViewPager\")文档的example推荐用 `TabsAdapter` 来做`ViewPager`的容器，但是在用`new TabsAdapter`的 `.addTab()` 方法时我不知道怎麽用`TabListener`来监听滑到当前Tab的方法,只能做一些视图的查看。\r\n    <pre>\r\n protected void onCreate(Bundle savedInstanceState) { \r\n    mViewPager = new ViewPager(this);\r\n    ....\r\n    setContentView(mViewPager);\r\n    ....\r\n    mTabsAdapter = new TabsAdapter(this, mViewPager);\r\n }\r\n </pre>\r\n\r\n效果如图：![](https://raw.github.com/hanaarena/blogcat/gh-pages/images/2013-10-19_121158.png)\r\n\r\n所以我选择了另一种方法List<view>来做每一屏(Tab)的容器:\r\n<pre>\r\nprotected void onCreate(Bundle savedInstanceState) {\r\n\tsuper.onCreate(savedInstanceState);\r\n\trequestWindowFeature(Window.FEATURE_NO_TITLE);\r\n\tsetContentView(R.layout.activity_main);\t\r\n\t\r\n\tviewPager = (ViewPager) this.findViewById(R.id.viewpager);\r\n\tpagerTitleStrip = (PagerTitleStrip) this.findViewById(R.id.pagertitile);\r\n\tpagerTitleStrip.setTextColor(Color.WHITE);\r\n\r\n\tView view1 = LayoutInflater.from(MainActivity.this).inflate(\r\n\t\t\t\tR.layout.tab1, null);\r\n\t....\r\n\r\n\tlist = new ArrayList<View>();\r\n\tlist.add(view1);\r\n\t...\r\n}\r\n</pre>\r\n\r\n效果如图：<br />\r\n![](https://raw.github.com/hanaarena/blogcat/gh-pages/images/2013-10-19_121507.png)\r\n\r\n在后者的方法能直接实现对每一屏(Tab)中各控件的事件监听，而无需去实现`TabsListener`之类的监听接口.\r\n\r\n#### Tab two\r\n第二屏中通过点击Button控件调用`Time/DatePickerDialog`来进行时间/日期的选择。([More about `Picker`](http://developer.android.com/guide/topics/ui/controls/pickers.html))\r\n\r\nTab2.xml:\r\n\r\n    <Button\r\n\t\tandroid:id=\"@+id/button1\"\r\n\t\tandroid:layout_width=\"wrap_content\"\r\n\t\tandroid:layout_height=\"wrap_content\"\r\n\t\t······\r\n\t\tandroid:text=\"@string/btn_date\" \r\n\t\tandroid:onClick=\"showdateTime\" />\r\n\r\n在实现类文件中实现`onClick`事件的方法(这里指`showdateTime`):\r\n\r\n\tpublic void showdateTime(View v)\r\n\t{\r\n\t\t// 创建一个TimePickerDialog实例，并把它显示出来。\r\n\t\tnew TimePickerDialog(MainActivity.this,\r\n\t\t\t0, // 绑定监听器\r\n\t\t\tnew TimePickerDialog.OnTimeSetListener()\r\n\t\t\t{\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onTimeSet(TimePicker tp, int hourOfDay,\r\n\t\t\t\t\tint minute)\r\n\t\t\t\t{\r\n\t\t\t\t\t myCalendar.setTimeInMillis(System.currentTimeMillis());        //设置Calendar对象\r\n\t\t\t\t\t myCalendar.set(Calendar.HOUR_OF_DAY, hourOfDay);        //设置闹钟小时数\r\n\t\t\t\t\t myCalendar.set(Calendar.MINUTE, minute);            //设置闹钟的分钟数\r\n\t\t\t\t\t myCalendar.set(Calendar.SECOND, 0);                //设置闹钟的秒数\r\n\t\t\t\t\t myCalendar.set(Calendar.MILLISECOND, 0);            //设置闹钟的毫秒数\r\n                     Intent intent = new Intent(MainActivity.this, AlarmReceiver.class);    //创建Intent对象\r\n                     PendingIntent pi = PendingIntent.getBroadcast(MainActivity.this, 0, intent, 0);    //创建PendingIntent          \r\n             \t\t // 获取AlarmManager对象\r\n             \t\t aManager = (AlarmManager) getSystemService(ALARM_SERVICE);\t\t\r\n                     aManager.set(AlarmManager.RTC_WAKEUP, myCalendar.getTimeInMillis(), pi);        //设置闹钟\r\n                     //aManager.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), pi);        //设置当前时间闹钟\r\n                     Toast.makeText(MainActivity.this, \"闹钟设置成功\", Toast.LENGTH_SHORT).show();//提示用户\r\n\t\t\t\t}\r\n\t\t\t}, myCalendar.get(Calendar.HOUR_OF_DAY)\r\n\t\t\t, myCalendar.get(Calendar.MINUTE), true)\r\n\t\t\t.show();\t\t\t\t\r\n\t}\r\n**Waring：**\r\n\r\n\tmyCalendar.set(Calendar.HOUR_OF_DAY, hourOfDay); \r\n与\r\n\r\n\tmyCalendar.set(Calendar.HOUR, hourOfDay); \r\n的区别，如果用HOUR的话只能识别12小时制(虽然能选择12点过后的钟点,但是并不能实现定时闹钟功能)。应使用HOUR_OF _DAY\r\n\r\n（P.s. 调用日期Picker同理~）\r\n\r\n下一步要先实现的是自定义`Toast`内容，即将`EditText`中的内容传输到`Toast`控件中，并用`SharedPreferenced`保存。<br />\r\n然后再调用`Noitification`.([More about `Notification`](http://developer.android.com/guide/topics/ui/notifiers/notifications.html))","google":"UA-30427812","note":"Don't delete this file! It's used internally to help with page regeneration."}